@inherits ComponentBase
@using LMKit.Maestro.Models
@using LMKit.TextGeneration.Chat
@using LMKit.TextProcessing

@inject IClipboardHandler ClipboardHandler
@inject IJSRuntime JS

<div id="message-container"
     class="@(MessageViewModel.Sender == MessageSender.Assistant ? "assistant-message-container" : "user-message-container")">
    <div class="message-content @(MessageViewModel.Sender == MessageSender.Assistant ? "assistant-message-content" : "user-message-content")">
        
       @if (MessageViewModel.Sender == MessageSender.Assistant)
       {
           @if (SegmentedContent != null && SegmentedContent.Count > 0)
           {
               @foreach (var segment in SegmentedContent)
               {
                   @if (segment.SegmentType == TextSegmentType.InternalReasoning)
                   {
                       <div class="thinking-block @(segment.IsActive ? "thinking-active" : "")">
                           <div class="thinking-header" @onclick="() => ToggleThinkingBlock(segment)">
                               <div class="thinking-header-left">
                                   <span class="thinking-icon">
                                       @if (segment.IsActive)
                                       {
                                           <span class="thinking-spinner"></span>
                                       }
                                       else
                                       {
                                           <i class="fas fa-brain"></i>
                                       }
                                   </span>
                                   <span class="thinking-title">
                                       @if (segment.IsActive)
                                       {
                                           <span>Thinking...</span>
                                       }
                                       else
                                       {
                                           <span>Thought for @FormatThinkingDuration(segment.Content)</span>
                                       }
                                   </span>
                               </div>
                               <span class="thinking-toggle">
                                   <i class="fas @(segment.IsExpanded ? "fa-chevron-up" : "fa-chevron-down")"></i>
                               </span>
                           </div>
                           @if (segment.IsExpanded || segment.IsActive)
                           {
                               <div class="thinking-content">
                                   <MudText Typo="Typo.body2" Class="thinking-text">
                                       @segment.Content
                                       @if (segment.IsActive)
                                       {
                                           <span class="dot ml-1 d-inline-block"></span>
                                       }
                                   </MudText>
                               </div>
                           }
                       </div>
                   }
                   else
                   {
                       @if (!string.IsNullOrEmpty(segment.Content))
                       {
                           <div class="markdown-content" data-markdown="true">@segment.Content</div>
                       }
                   }
               }
           }
           else
           {
               @* Fallback: render content directly *@
               var content = MessageViewModel.GetContent(responseIndex);
               @if (!string.IsNullOrEmpty(content))
               {
                   <div class="markdown-content" data-markdown="true">@content</div>
               }
           }
       }
       else
       {
           @* Display attachments for user messages *@
           @if (MessageViewModel.HasAttachments)
           {
               <div class="message-attachments">
                   @foreach (var attachment in MessageViewModel.Attachments)
                   {
                       <div class="message-attachment-item">
                           @if (attachment.IsImage && !string.IsNullOrEmpty(attachment.ThumbnailBase64))
                           {
                               <img src="data:@attachment.MimeType;base64,@attachment.ThumbnailBase64" 
                                    alt="@attachment.FileName" 
                                    class="message-attachment-image"
                                    @ondblclick="() => OpenLightbox(attachment)"
                                    title="Double-click to zoom" />
                           }
                           else if (attachment.IsPdf)
                           {
                               <div class="message-attachment-pdf">
                                   <i class="fas fa-file-pdf"></i>
                                   <span class="message-attachment-name">@attachment.FileName</span>
                               </div>
                           }
                       </div>
                   }
               </div>
           }
           <MudText Typo="Typo.body1">
               @MessageViewModel.GetContent(responseIndex)
           </MudText>
       }
    </div>

    @if (MessageViewModel.Sender == MessageSender.User || (MessageViewModel.Sender == MessageSender.Assistant && !MessageViewModel.MessageInProgress))
    {
        <div class="message-footer @(MessageJustTerminated ? "show" : "hide")">
            <div class="message-footer-content @(MessageViewModel.Sender == MessageSender.User ? "user-message-footer-content" : "")">
                @if (MessageViewModel.GetResponseCount() > 1)
                {
                    <button title="@Locales.PreviousGeneratedResponse" @onclick="OnPreviousResponseButtonClicked"
                            class="chat-action-button ">
                        <i class="fas fa-chevron-left"/>
                    </button>

                    <MudText Class="mx-1 outline" Typo="Typo.overline" Style="font-size: 0.7rem">
                        @($"{responseIndex + 1} / {MessageViewModel.GetResponseCount()}")
                        </MudText>

                    <button title="@Locales.NextGeneratedResponse" @onclick="OnNextResponseButtonClicked"
                            class="chat-action-button">
                        <i class="fas fa-chevron-right" />
                    </button>
                }

                <button title="@Locales.CopyMessage" @onclick="OnCopyMessageButtonClicked"
                        class="chat-action-button">
                    <i class="fas @(MessageJustCopied ? "fa-check" : "fa-copy")" />
                </button>

                @if (MessageViewModel.Sender == MessageSender.Assistant)
                {
                    if (MessageViewModel.IsLastAssistantMessage)
                    {
                        <button title="@Locales.RegenerateResponse" @onclick="OnRegenerateResponseButtonClicked"
                                class="chat-action-button">
                            <i class="fas fa-rotate" />
                        </button>
                    }

                    @if (MessageViewModel.GetTerminationReason(responseIndex) != LMKit.TextGeneration.TextGenerationResult.StopReason.Unknown)
                    {
                        <MudText Class="ml-1 outline" Typo="Typo.overline" Style="font-size: 0.7rem">
                            @($"{MessageViewModel.GetGeneratedTokens(responseIndex)} tokens â€¢ Termination reason: {MessageViewModel.GetTerminationReason(responseIndex)}")
                        </MudText>
                    }
                }
            </div>
        </div>
    }
</div>

@* Image Lightbox Overlay *@
@if (_lightboxAttachment != null)
{
    <div class="lightbox-overlay" @onclick="CloseLightbox">
        <div class="lightbox-content" @onclick:stopPropagation="true">
            <img src="data:@_lightboxAttachment.MimeType;base64,@_lightboxAttachment.ThumbnailBase64" 
                 alt="@_lightboxAttachment.FileName" 
                 class="lightbox-image" />
            <div class="lightbox-filename">@_lightboxAttachment.FileName</div>
        </div>
        <button class="lightbox-close" @onclick="CloseLightbox" title="Close">
            <i class="fas fa-times"></i>
        </button>
    </div>
}

@code {

    // Lightbox state
    private ChatAttachment? _lightboxAttachment = null;

    private void OpenLightbox(ChatAttachment attachment)
    {
        _lightboxAttachment = attachment;
        InvokeAsync(StateHasChanged);
    }

    private void CloseLightbox()
    {
        _lightboxAttachment = null;
        InvokeAsync(StateHasChanged);
    }

    private int responseIndex;

    private int ResponseIndex
    {
        get => responseIndex;
        set
        {
            responseIndex = value;
            UpdateSegmentedContent();
        }
    }

    // Segmented content for rendering
    private List<SegmentRenderInfo> SegmentedContent { get; set; } = new();

    public class SegmentRenderInfo
    {
        public TextSegmentType SegmentType { get; set; }
        public string Content { get; set; } = "";
        public bool IsExpanded { get; set; } = false;
        public bool IsActive { get; set; } = false;
    }

    private void ToggleThinkingBlock(SegmentRenderInfo segment)
    {
        if (!segment.IsActive)
        {
            segment.IsExpanded = !segment.IsExpanded;
            InvokeAsync(StateHasChanged);
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);
        
        // Render markdown content via JavaScript
        if (MessageViewModel.Sender == MessageSender.Assistant)
        {
            try
            {
                await JS.InvokeVoidAsync("renderMarkdown");
            }
            catch
            {
                // Ignore JS interop errors
            }
        }
    }

    private string FormatThinkingDuration(string content)
    {
        // Estimate thinking duration based on content length (rough approximation)
        int wordCount = content?.Split(new[] { ' ', '\n', '\r' }, StringSplitOptions.RemoveEmptyEntries).Length ?? 0;
        if (wordCount < 50) return "a moment";
        if (wordCount < 150) return "a few seconds";
        if (wordCount < 500) return "several seconds";
        return "a while";
    }

    bool messageJustCopied;

    bool MessageJustCopied
    {
        get => messageJustCopied;
        set
        {
            messageJustCopied = value;
            InvokeAsync(() => StateHasChanged());
        }
    }

    bool messageJustTerminated;

    bool MessageJustTerminated
    {
        get => messageJustTerminated;
        set
        {
            messageJustTerminated = value;
            InvokeAsync(() => StateHasChanged());
        }
    }

    MessageViewModel? messageViewModel;
    [Parameter]
    [EditorRequired]
#pragma warning disable BL0007
    public MessageViewModel MessageViewModel
    {
        get => messageViewModel!;
        set
        {
            if (messageViewModel != value)
            {
                if (messageViewModel != null)
                {
                    messageViewModel.PropertyChanged -= OnMessageViewModelPropertyChanged;
                }

                messageViewModel = value;
                messageViewModel.PropertyChanged += OnMessageViewModelPropertyChanged;
                messageViewModel.OnRegeneratedResponse += OnRegeneratedResponse;

                if (MessageViewModel.GetResponseCount() > 1)
                {
                    responseIndex = MessageViewModel.GetResponseCount() - 1;
                }
                else
                {
                    responseIndex = 0;
                }

                if (messageViewModel.Sender == MessageSender.Assistant)
                {
                    UpdateSegmentedContent();
                }

                InvokeAsync(() => StateHasChanged());
            }
        }
    }
#pragma warning restore BL0007

    private void UpdateSegmentedContent()
    {
        var segments = MessageViewModel.GetSegments(responseIndex);
        var newContent = new List<SegmentRenderInfo>();

        if (segments != null && segments.Count > 0)
        {
            for (int i = 0; i < segments.Count; i++)
            {
                var segment = segments[i];
                bool isLastSegment = i == segments.Count - 1;
                bool isActive = isLastSegment && MessageViewModel.MessageInProgress;

                var renderInfo = new SegmentRenderInfo
                {
                    SegmentType = segment.SegmentType,
                    Content = segment.Content,
                    IsActive = isActive,
                    IsExpanded = isActive // Auto-expand active thinking blocks
                };

                newContent.Add(renderInfo);
            }
        }

        // Preserve expansion state for existing segments
        for (int i = 0; i < newContent.Count && i < SegmentedContent.Count; i++)
        {
            if (newContent[i].SegmentType == SegmentedContent[i].SegmentType &&
                newContent[i].SegmentType == TextSegmentType.InternalReasoning)
            {
                newContent[i].IsExpanded = SegmentedContent[i].IsExpanded || newContent[i].IsActive;
            }
        }

        SegmentedContent = newContent;
    }

    private void OnRegeneratedResponse(object? sender, EventArgs e)
    {
        ResponseIndex = MessageViewModel.GetResponseCount() - 1;
        InvokeAsync(() => StateHasChanged());
    }

    private void OnMessageViewModelPropertyChanged(object? sender, System.ComponentModel.PropertyChangedEventArgs e)
    {
        if (MessageViewModel.Sender == MessageSender.Assistant)
        {
            if (e.PropertyName == nameof(MessageViewModel.Content) || 
                e.PropertyName == nameof(MessageViewModel.Segments))
            {
                UpdateSegmentedContent();
            }
            else if (e.PropertyName == nameof(MessageViewModel.MessageInProgress))
            {
                if (!MessageViewModel.MessageInProgress)
                {
                    OnAssistantMessageJustTerminated();
                    UpdateSegmentedContent(); // Update to mark segments as no longer active
                }
            }
        }

        InvokeAsync(() => StateHasChanged());
    }

    private void OnAssistantMessageJustTerminated()
    {
        var _ = Task.Run(async () =>
        {
            MessageJustTerminated = true;
            try
            {
                await Task.Delay(5000);
            }
            catch (Exception)
            {
            }

            MessageJustTerminated = false;
        });
    }

    private async Task OnCopyMessageButtonClicked()
    {
        // Copy only visible content (excluding thinking/reasoning segments)
        string contentToCopy = GetVisibleContent(responseIndex);
        bool success = await ClipboardHandler.CopyTextToClipboardAsync(contentToCopy);

        if (success)
        {
            if (!MessageJustCopied)
            {
                var _ = Task.Run(async () =>
                {
                    MessageJustCopied = true;
                    await Task.Delay(3000);
                    MessageJustCopied = false;
                });
            }
        }
    }

    /// <summary>
    /// Gets the visible content (excluding InternalReasoning segments) for clipboard copy.
    /// </summary>
    private string GetVisibleContent(int messageIndex)
    {
        var segments = MessageViewModel.GetSegments(messageIndex);
        
        if (segments == null || segments.Count == 0)
        {
            return MessageViewModel.GetContent(messageIndex);
        }

        // Only include UserVisible, ToolResponse, and Undefined segments (not InternalReasoning)
        var visibleParts = segments
            .Where(s => s.SegmentType != TextSegmentType.InternalReasoning)
            .Select(s => s.Content)
            .ToList();

        if (visibleParts.Count == 0)
        {
            return MessageViewModel.GetContent(messageIndex);
        }

        return string.Join("", visibleParts).Trim();
    }

    private void OnRegenerateResponseButtonClicked()
    {
        MessageViewModel.ParentConversation.RegenerateResponse(MessageViewModel);
    }

    private void OnPreviousResponseButtonClicked()
    {
        if (ResponseIndex > 0)
        {
            ResponseIndex--;
        }
    }

    private void OnNextResponseButtonClicked()
    {
        if (ResponseIndex < MessageViewModel.GetResponseCount() - 1)
        {
            ResponseIndex++;
        }
    }

    private static string GetStatusText(LMKitRequestStatus status)
    {
        switch (status)
        {
            default:
                return string.Empty;

            case LMKitRequestStatus.Cancelled:
                return "Cancelled";

            case LMKitRequestStatus.GenericError:
                return "Unknown error";
        }
    }

}
