<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
    <title>Maestro</title>
    <base href="/" />
    <link rel="icon" href="data:,">
    <link rel="stylesheet" href="Maestro.styles.css" />
    <link rel="stylesheet" href="css/lmkitmaestro.css" />
    <link rel="stylesheet" href="css/font-awesome/css/all.min.css" />
    <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap" rel="stylesheet" />
    <link href="_content/MudBlazor/MudBlazor.min.css" rel="stylesheet" />
</head>

<body>
    <div style="background-color: var(--Background); overflow: hidden" class="dark" id="app">
        <div class="loading-content">
            <div class="spinner">
                <div> </div>
                <div> </div>
                <div> </div>
                <div> </div>
            </div>
        </div>
    </div>

    <div id="blazor-error-ui">
        An unhandled error has occurred.
        <a href="" class="reload">Reload</a>
        <a class="dismiss">ðŸ—™</a>
    </div>

    <script src="js/lmkitmaestro.js"></script>
    <script src="_framework/blazor.webview.js" autostart="false"></script>
    <script src="_content/MudBlazor/MudBlazor.min.js"></script>
    
    <!-- Simple Markdown renderer -->
    <script>
        // Simple markdown parser for tables, bold, italic, code, lists
        function parseMarkdown(text) {
            if (!text) return '';
            
            // Normalize line endings, remove BOM and other invisible chars, then trim
            let html = text
                .replace(/^\uFEFF/, '')           // Remove BOM
                .replace(/\r\n/g, '\n')           // Normalize Windows line endings
                .replace(/\r/g, '\n')             // Normalize old Mac line endings
                .replace(/[\u200B-\u200D\uFEFF]/g, '') // Remove zero-width chars
                .trim();
            
            // Process headings FIRST (before HTML escaping) - line by line
            // This ensures ## at line start is detected properly
            html = html.split('\n').map(line => {
                // Check for headings (must have space after #)
                const match = line.match(/^(#{1,6})\s+(.*)$/);
                if (match) {
                    const level = match[1].length;
                    const content = match[2].replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                    return `<h${level}>${content}</h${level}>`;
                }
                return line;
            }).join('\n');
            
            // Now escape HTML in non-heading content
            // We need to be careful not to escape the <h> tags we just created
            html = html.split('\n').map(line => {
                if (line.match(/^<h[1-6]>.*<\/h[1-6]>$/)) {
                    return line; // Don't escape heading lines
                }
                return line.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
            }).join('\n');
            
            // Code blocks (``` ... ```)
            html = html.replace(/```(\w*)\n([\s\S]*?)```/g, '<pre><code class="language-$1">$2</code></pre>');
            
            // Inline code (`code`)
            html = html.replace(/`([^`]+)`/g, '<code>$1</code>');
            
            // Tables
            html = parseMarkdownTables(html);
            
            // Bold (**text** or __text__) - must be before italic
            html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
            html = html.replace(/__(.+?)__/g, '<strong>$1</strong>');
            
            // Italic (*text* or _text_) - non-greedy, single asterisks only
            html = html.replace(/\*([^*]+)\*/g, '<em>$1</em>');
            html = html.replace(/\b_([^_]+)_\b/g, '<em>$1</em>');
            
            // Horizontal rule
            html = html.replace(/^---+$/gm, '<hr>');
            html = html.replace(/^\*\*\*+$/gm, '<hr>');
            
            // Unordered lists
            html = html.replace(/^[ \t]*[-*+][ \t]+(.+)$/gm, '<li>$1</li>');
            html = html.replace(/(<li>.*<\/li>\n?)+/g, '<ul>$&</ul>');
            
            // Ordered lists
            html = html.replace(/^[ \t]*\d+\.[ \t]+(.+)$/gm, '<li>$1</li>');
            
            // Links [text](url)
            html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank">$1</a>');
            
            // LaTeX blocks \[ ... \] - wrap in a styled div
            html = html.replace(/\\\[([\s\S]*?)\\\]/g, '<div class="math-block"><code>$1</code></div>');
            
            // Inline LaTeX \( ... \)
            html = html.replace(/\\\(([^)]+)\\\)/g, '<code class="math-inline">$1</code>');
            
            // Line breaks - convert double newlines to paragraphs
            // First, ensure headings are separated from following content
            html = html.replace(/(<\/h[1-6]>)\n(?!\n)/g, '$1\n\n');
            
            html = html.split(/\n\n+/).map(p => {
                p = p.trim();
                if (p && !p.startsWith('<h') && !p.startsWith('<ul') && !p.startsWith('<ol') && 
                    !p.startsWith('<pre') && !p.startsWith('<table') && !p.startsWith('<hr') &&
                    !p.startsWith('<div class="math')) {
                    return '<p>' + p.replace(/\n/g, '<br>') + '</p>';
                }
                return p;
            }).join('\n');
            
            return html;
        }
        
        function parseMarkdownTables(text) {
            const lines = text.split('\n');
            let result = [];
            let inTable = false;
            let tableRows = [];
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                // Check if this is a table row (starts and ends with |, or has | in middle)
                if (line.match(/^\|.*\|$/)) {
                    // Check if this is a separator row (|---|---|)
                    const isSeparator = line.match(/^\|[\s-:|]+\|$/);
                    
                    if (isSeparator) {
                        // Skip separator rows
                        continue;
                    }
                    
                    if (!inTable) {
                        inTable = true;
                        tableRows = [];
                    }
                    
                    // Parse cells
                    const cells = line.split('|').filter((c, idx, arr) => idx > 0 && idx < arr.length - 1);
                    tableRows.push(cells.map(c => c.trim()));
                } else {
                    if (inTable && tableRows.length > 0) {
                        // End of table, render it
                        result.push(renderTable(tableRows));
                        tableRows = [];
                        inTable = false;
                    }
                    result.push(line);
                }
            }
            
            // Handle table at end of text
            if (inTable && tableRows.length > 0) {
                result.push(renderTable(tableRows));
            }
            
            return result.join('\n');
        }
        
        function renderTable(rows) {
            if (rows.length === 0) return '';
            
            let html = '<table>';
            
            // First row is header
            html += '<thead><tr>';
            rows[0].forEach(cell => {
                html += '<th>' + cell + '</th>';
            });
            html += '</tr></thead>';
            
            // Rest are body rows
            if (rows.length > 1) {
                html += '<tbody>';
                for (let i = 1; i < rows.length; i++) {
                    html += '<tr>';
                    rows[i].forEach(cell => {
                        html += '<td>' + cell + '</td>';
                    });
                    html += '</tr>';
                }
                html += '</tbody>';
            }
            
            html += '</table>';
            return html;
        }

        // Render markdown from hidden source span to content div
        function renderMarkdown() {
            const wrappers = document.querySelectorAll('.markdown-wrapper');
            wrappers.forEach(wrapper => {
                const sourceEl = wrapper.querySelector('.md-source');
                const contentEl = wrapper.querySelector('.markdown-content');
                
                if (sourceEl && contentEl) {
                    const raw = sourceEl.textContent;
                    const hash = hashCode(raw);
                    
                    // Only render if content changed
                    if (raw && wrapper.dataset.lastHash !== String(hash)) {
                        contentEl.innerHTML = parseMarkdown(raw);
                        wrapper.dataset.lastHash = String(hash);
                    }
                }
            });
        }
        
        // Simple hash function for change detection
        function hashCode(str) {
            if (!str) return 0;
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return hash;
        }

        // Run frequently during streaming
        let renderInterval;
        const observer = new MutationObserver(() => {
            renderMarkdown();
        });
        
        document.addEventListener('DOMContentLoaded', () => {
            observer.observe(document.body, { 
                childList: true, 
                subtree: true, 
                characterData: true
            });
            // Also poll for streaming updates
            renderInterval = setInterval(renderMarkdown, 100);
            renderMarkdown();
        });
    </script>
</body>

</html>
