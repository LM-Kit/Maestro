<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
    <title>Maestro</title>
    <base href="/" />
    <link rel="icon" href="data:,">
    <link rel="stylesheet" href="Maestro.styles.css" />
    <link rel="stylesheet" href="css/lmkitmaestro.css" />
    <link rel="stylesheet" href="css/font-awesome/css/all.min.css" />
    <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap" rel="stylesheet" />
    <link href="_content/MudBlazor/MudBlazor.min.css" rel="stylesheet" />
</head>

<body>
    <div style="background-color: var(--Background); overflow: hidden" class="dark" id="app">
        <div class="loading-content">
            <div class="spinner">
                <div> </div>
                <div> </div>
                <div> </div>
                <div> </div>
            </div>
        </div>
    </div>

    <div id="blazor-error-ui">
        An unhandled error has occurred.
        <a href="" class="reload">Reload</a>
        <a class="dismiss">üóô</a>
    </div>

    <script src="js/lmkitmaestro.js"></script>
    <script src="_framework/blazor.webview.js" autostart="false"></script>
    <script src="_content/MudBlazor/MudBlazor.min.js"></script>
    
    <!-- Simple Markdown renderer -->
    <script>
        // Convert basic LaTeX to HTML (no external library needed)
        function latexToHtml(latex) {
            let html = latex.trim();
            
            // Remove spacing commands first
            html = html.replace(/\\;/g, ' ');
            html = html.replace(/\\,/g, ' ');
            html = html.replace(/\\!/g, '');
            html = html.replace(/\\quad/g, '  ');
            html = html.replace(/\\qquad/g, '    ');
            html = html.replace(/\\ /g, ' ');
            
            // Greek letters
            html = html.replace(/\\alpha/g, 'Œ±');
            html = html.replace(/\\beta/g, 'Œ≤');
            html = html.replace(/\\gamma/g, 'Œ≥');
            html = html.replace(/\\delta/g, 'Œ¥');
            html = html.replace(/\\epsilon/g, 'Œµ');
            html = html.replace(/\\theta/g, 'Œ∏');
            html = html.replace(/\\lambda/g, 'Œª');
            html = html.replace(/\\mu/g, 'Œº');
            html = html.replace(/\\pi/g, 'œÄ');
            html = html.replace(/\\sigma/g, 'œÉ');
            html = html.replace(/\\phi/g, 'œÜ');
            html = html.replace(/\\omega/g, 'œâ');
            html = html.replace(/\\Sigma/g, 'Œ£');
            html = html.replace(/\\Pi/g, 'Œ†');
            html = html.replace(/\\Omega/g, 'Œ©');
            html = html.replace(/\\Delta/g, 'Œî');
            
            // Math symbols
            html = html.replace(/\\times/g, '√ó');
            html = html.replace(/\\div/g, '√∑');
            html = html.replace(/\\pm/g, '¬±');
            html = html.replace(/\\mp/g, '‚àì');
            html = html.replace(/\\cdot/g, '¬∑');
            html = html.replace(/\\leq/g, '‚â§');
            html = html.replace(/\\geq/g, '‚â•');
            html = html.replace(/\\neq/g, '‚â†');
            html = html.replace(/\\approx/g, '‚âà');
            html = html.replace(/\\equiv/g, '‚â°');
            html = html.replace(/\\infty/g, '‚àû');
            html = html.replace(/\\sqrt\{([^}]+)\}/g, '‚àö($1)');
            html = html.replace(/\\sqrt/g, '‚àö');
            html = html.replace(/\\sum/g, 'Œ£');
            html = html.replace(/\\prod/g, 'Œ†');
            html = html.replace(/\\int/g, '‚à´');
            html = html.replace(/\\partial/g, '‚àÇ');
            html = html.replace(/\\nabla/g, '‚àá');
            html = html.replace(/\\rightarrow/g, '‚Üí');
            html = html.replace(/\\leftarrow/g, '‚Üê');
            html = html.replace(/\\Rightarrow/g, '‚áí');
            html = html.replace(/\\Leftarrow/g, '‚áê');
            html = html.replace(/\\forall/g, '‚àÄ');
            html = html.replace(/\\exists/g, '‚àÉ');
            html = html.replace(/\\in/g, '‚àà');
            html = html.replace(/\\notin/g, '‚àâ');
            html = html.replace(/\\subset/g, '‚äÇ');
            html = html.replace(/\\supset/g, '‚äÉ');
            html = html.replace(/\\cup/g, '‚à™');
            html = html.replace(/\\cap/g, '‚à©');
            
            // Fractions: \frac{a}{b} ‚Üí a/b or (a)/(b)
            html = html.replace(/\\frac\{([^}]+)\}\{([^}]+)\}/g, '<span class="math-frac"><span class="math-num">$1</span><span class="math-denom">$2</span></span>');
            
            // Superscripts: ^{...} or ^x
            html = html.replace(/\^\{([^}]+)\}/g, '<sup>$1</sup>');
            html = html.replace(/\^(\w)/g, '<sup>$1</sup>');
            
            // Subscripts: _{...} or _x
            html = html.replace(/_\{([^}]+)\}/g, '<sub>$1</sub>');
            html = html.replace(/_(\w)/g, '<sub>$1</sub>');
            
            // Text in math: \text{...}
            html = html.replace(/\\text\{([^}]+)\}/g, '<span class="math-text">$1</span>');
            
            // Bold/italic
            html = html.replace(/\\mathbf\{([^}]+)\}/g, '<strong>$1</strong>');
            html = html.replace(/\\mathit\{([^}]+)\}/g, '<em>$1</em>');
            
            // Clean up remaining braces
            html = html.replace(/\{/g, '');
            html = html.replace(/\}/g, '');
            
            // Clean up any remaining backslashes before letters (unknown commands)
            html = html.replace(/\\([a-zA-Z]+)/g, '$1');
            
            return html;
        }
        
        // Render LaTeX - uses latexToHtml converter
        function renderLatex(latex, displayMode) {
            const html = latexToHtml(latex);
            if (displayMode) {
                return '<div class="math-block">' + html + '</div>';
            }
            return '<span class="math-inline">' + html + '</span>';
        }
        
        // Simple markdown parser for tables, bold, italic, code, lists
        function parseMarkdown(text) {
            if (!text) return '';
            
            // Normalize line endings, remove BOM and other invisible chars, then trim
            let html = text
                .replace(/^\uFEFF/, '')           // Remove BOM
                .replace(/\r\n/g, '\n')           // Normalize Windows line endings
                .replace(/\r/g, '\n')             // Normalize old Mac line endings
                .replace(/[\u200B-\u200D\uFEFF]/g, '') // Remove zero-width chars
                .trim();
            
            // Process headings FIRST (before HTML escaping) - line by line
            // This ensures ## at line start is detected properly
            html = html.split('\n').map(line => {
                // Check for headings (must have space after #)
                const match = line.match(/^(#{1,6})\s+(.*)$/);
                if (match) {
                    const level = match[1].length;
                    const content = match[2].replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                    return `<h${level}>${content}</h${level}>`;
                }
                return line;
            }).join('\n');
            
            // Now escape HTML in non-heading content
            // We need to be careful not to escape the <h> tags we just created
            html = html.split('\n').map(line => {
                if (line.match(/^<h[1-6]>.*<\/h[1-6]>$/)) {
                    return line; // Don't escape heading lines
                }
                return line.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
            }).join('\n');
            
            // Code blocks (``` ... ```)
            html = html.replace(/```(\w*)\n([\s\S]*?)```/g, '<pre><code class="language-$1">$2</code></pre>');
            
            // Inline code (`code`)
            html = html.replace(/`([^`]+)`/g, '<code>$1</code>');
            
            // Tables
            html = parseMarkdownTables(html);
            
            // Bold (**text** or __text__) - must be before italic
            html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
            html = html.replace(/__(.+?)__/g, '<strong>$1</strong>');
            
            // Italic (*text* or _text_) - non-greedy, single asterisks only
            html = html.replace(/\*([^*]+)\*/g, '<em>$1</em>');
            html = html.replace(/\b_([^_]+)_\b/g, '<em>$1</em>');
            
            // Horizontal rule
            html = html.replace(/^---+$/gm, '<hr>');
            html = html.replace(/^\*\*\*+$/gm, '<hr>');
            
            // Unordered lists
            html = html.replace(/^[ \t]*[-*+][ \t]+(.+)$/gm, '<li>$1</li>');
            html = html.replace(/(<li>.*<\/li>\n?)+/g, '<ul>$&</ul>');
            
            // Ordered lists
            html = html.replace(/^[ \t]*\d+\.[ \t]+(.+)$/gm, '<li>$1</li>');
            
            // Links [text](url)
            html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank">$1</a>');
            
            // LaTeX blocks \[ ... \] - render with KaTeX if available
            html = html.replace(/\\\[([\s\S]*?)\\\]/g, (match, latex) => {
                return renderLatex(latex.trim(), true);
            });
            
            // Inline LaTeX \( ... \)
            html = html.replace(/\\\(([^)]+)\\\)/g, (match, latex) => {
                return renderLatex(latex.trim(), false);
            });
            
            // Line breaks - convert double newlines to paragraphs
            // First, ensure headings are separated from following content
            html = html.replace(/(<\/h[1-6]>)\n(?!\n)/g, '$1\n\n');
            
            html = html.split(/\n\n+/).map(p => {
                p = p.trim();
                if (p && !p.startsWith('<h') && !p.startsWith('<ul') && !p.startsWith('<ol') && 
                    !p.startsWith('<pre') && !p.startsWith('<table') && !p.startsWith('<hr') &&
                    !p.startsWith('<div class="math')) {
                    return '<p>' + p.replace(/\n/g, '<br>') + '</p>';
                }
                return p;
            }).join('\n');
            
            return html;
        }
        
        function parseMarkdownTables(text) {
            const lines = text.split('\n');
            let result = [];
            let inTable = false;
            let tableRows = [];
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                // Check if this is a table row (starts and ends with |, or has | in middle)
                if (line.match(/^\|.*\|$/)) {
                    // Check if this is a separator row (|---|---|)
                    const isSeparator = line.match(/^\|[\s-:|]+\|$/);
                    
                    if (isSeparator) {
                        // Skip separator rows
                        continue;
                    }
                    
                    if (!inTable) {
                        inTable = true;
                        tableRows = [];
                    }
                    
                    // Parse cells
                    const cells = line.split('|').filter((c, idx, arr) => idx > 0 && idx < arr.length - 1);
                    tableRows.push(cells.map(c => c.trim()));
                } else {
                    if (inTable && tableRows.length > 0) {
                        // End of table, render it
                        result.push(renderTable(tableRows));
                        tableRows = [];
                        inTable = false;
                    }
                    result.push(line);
                }
            }
            
            // Handle table at end of text
            if (inTable && tableRows.length > 0) {
                result.push(renderTable(tableRows));
            }
            
            return result.join('\n');
        }
        
        function renderTable(rows) {
            if (rows.length === 0) return '';
            
            let html = '<table>';
            
            // First row is header
            html += '<thead><tr>';
            rows[0].forEach(cell => {
                html += '<th>' + cell + '</th>';
            });
            html += '</tr></thead>';
            
            // Rest are body rows
            if (rows.length > 1) {
                html += '<tbody>';
                for (let i = 1; i < rows.length; i++) {
                    html += '<tr>';
                    rows[i].forEach(cell => {
                        html += '<td>' + cell + '</td>';
                    });
                    html += '</tr>';
                }
                html += '</tbody>';
            }
            
            html += '</table>';
            return html;
        }

        // Render markdown from hidden source span to content div
        function renderMarkdown() {
            const wrappers = document.querySelectorAll('.markdown-wrapper');
            wrappers.forEach(wrapper => {
                const sourceEl = wrapper.querySelector('.md-source');
                const contentEl = wrapper.querySelector('.markdown-content');
                
                if (sourceEl && contentEl) {
                    const raw = sourceEl.textContent;
                    const hash = hashCode(raw);
                    
                    // Only render if content changed
                    if (raw && wrapper.dataset.lastHash !== String(hash)) {
                        contentEl.innerHTML = parseMarkdown(raw);
                        wrapper.dataset.lastHash = String(hash);
                    }
                }
            });
        }
        
        // Simple hash function for change detection
        function hashCode(str) {
            if (!str) return 0;
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return hash;
        }

        // Run frequently during streaming
        let renderInterval;
        const observer = new MutationObserver(() => {
            renderMarkdown();
        });
        
        document.addEventListener('DOMContentLoaded', () => {
            observer.observe(document.body, { 
                childList: true, 
                subtree: true, 
                characterData: true
            });
            // Also poll for streaming updates
            renderInterval = setInterval(renderMarkdown, 100);
            renderMarkdown();
        });
    </script>
</body>

</html>
